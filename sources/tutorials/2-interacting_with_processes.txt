Tutorial 2: Interacting with processes
======================================

Many programs require some form of input.  This input can be in the form of
commandline arguments or STDIN.  Some programs require this input at their
launch, others require it during the lifetime of the process.  Let's start
with the former::

	from sh import sed
	
	data = "one two three"
	fixed = sed(e="s/you're code/your code/", _in=data)
	
``sed`` is a program that can take input in the form of a file or piped from
STDIN.  Here, we choose to use STDIN by using the ``_in``
:ref:`special keyword argument <special_arguments>`.

Now let's try a more complicated example.  Using subprocesses to interact with
SSH is notoriously difficult.  It is recommended that you just ``ssh-copy-id``
to copy your public key to the server so you don't need to enter your password,
but for the purposes of this demonstration, we try to enter a password.

To interact with a process, we need to assign a callback to STDOUT.  See
Tutorial 1 for in-depth explanation of callbacks.  Unlike tutorial 1, this callback
will take 2 arguments instead of 1.  #1 is the STDOUT chunk,
and #2 will be a STDIN object that we can ``.put()`` chunks on (because it's
just a Queue).

Here's our first attempt::

	from sh import ssh
	
	def ssh_interact(line, stdin):
	    line = line.strip()
	    print(line)
	    if line.endswith("password:"):
	        stdin.put("correcthorsebatterystaple")
		
	p = ssh("10.10.10.100", _out=ssh_interact)
	p.wait()
	
If you run this (substituting an IP that you can SSH to), you'll notice that
nothing is printed.  The problem has to do with STDOUT buffering.  By default,
STDOUT is line-buffered, which means that you will only receive output when
sh encounters a newline in the output.  This is a problem because the password
prompt has no newline:

	amoffat@10.10.10.100's password:
	
Because a newline is never encountered, nothing is printed.  So we need to change
the STDOUT buffering.  We do this with the ``_out_bufsize``
:ref:`special keyword argument <special_arguments>`.  We'll set it to 0 for
unbuffered output, so we'll receive each character as the process writes it::

	from sh import ssh
	
	def ssh_interact(line, stdin):
	    line = line.strip()
	    print(line)
	    if line.endswith("password:"):
	        stdin.put("correcthorsebatterystaple")
		
	p = ssh("10.10.10.100", _out=ssh_interact, _out_bufsize=0)
	p.wait()

If you run this updated version, you'll notice a new problem.  The output looks
like this::

	'a'
	'm'
	'o'
	'f'
	'f'
	'a'
	't'
	'@'
	'1'
	'0'
	'.'
	'1'
	'0'
	'.'
	'1'
	'0'
	'.'
	'1'
	'0'
	'0'
	"'"
	's'
	' '
	'p'
	'a'
	's'
	's'
	'w'
	'o'
	'r'
	'd'
	':'
	' '
	
This is because the chunks of STDOUT our callback is receiving are unbuffered,
and are therefore individual characters, instead of entire lines.  What we need
to do now is aggregate this character-by-character data into something more
meaningful for us to test on.  It would make more sense to encapsulate the
variable we use into some kind of closure or class, but to keep it simple,
we'll just use a global::

	from sh import ssh
	import os, sys
	
	# open stdout in unbuffered mode
	sys.stdout = os.fdopen(sys.stdout.fileno(), "w", 0)
	
	aggregated = ""
	def ssh_interact(char, stdin):
	    sys.stdout.write(char)
	    aggregated += char
	    if aggregated.endswith("password: "):
	        stdin.put("correcthorsebatterystaple")
		
	p = ssh("10.10.10.100", _out=ssh_interact, _out_bufsize=0)
	p.wait()
	
Also notice that we open ``sys.stdout`` in unbuffered mode by re-opening it
with ``os.fdopen``.
This allows us to use ``sys.stdout.write`` to print each character as we
receive it, without adding a newline, and without us needing to ``.flush()`` it.

You'll also notice that the example still doesn't work.  There are two problems:
The first is that your password must end with a newline, as if you had typed
it and hit the return key.  This is because SSH has no idea how long your
password is, and is line-buffering STDIN.  The second problem lies
deeper in SSH.  Long story short, SSH needs a TTY attached
to its STDIN in order to work properly.  This "tricks" SSH into believing that
it is interacting with a real user in a real terminal session.
To enable TTY, we can add the ``_tty_in`` special keyword argument::

	from sh import ssh
	import os, sys
	
	# open stdout in unbuffered mode
	sys.stdout = os.fdopen(sys.stdout.fileno(), "w", 0)
	
	aggregated = ""
	def ssh_interact(char, stdin):
	    global aggregated
	    sys.stdout.write(char)
	    aggregated += char
	    if aggregated.endswith("password: "):
	        stdin.put("correcthorsebatterystaple\n")
		
	p = ssh("10.10.10.100", _out=ssh_interact, _out_bufsize=0, _tty_in=True)
	p.wait()
	
Voil√†::

	amoffat@10.10.10.100's password: 
	Linux 10.10.10.100 testhost #1 SMP Tue Jun 21 10:29:24 EDT 2011 i686 GNU/Linux
	Ubuntu 10.04.2 LTS
	
	Welcome to Ubuntu!
	 * Documentation:  https://help.ubuntu.com/
	
	66 packages can be updated.
	53 updates are security updates.
	
	Ubuntu 10.04.2 LTS
	
	Welcome to Ubuntu!
	 * Documentation:  https://help.ubuntu.com/
	You have new mail.
	Last login: Thu Sep 13 03:53:00 2012 from some.ip.address
	amoffat@10.10.10.100:~$ 
	
	
	